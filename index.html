<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>RobloxWeb Engine 2.0</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body { margin: 0; overflow: hidden; user-select: none; background-color: #1e1e1e; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .roblox-font { font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; font-weight: 800; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px; }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .text-shadow-sm { text-shadow: 1px 1px 2px rgba(0,0,0,0.8); }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="text-white bg-slate-900">

    <!-- MAIN DASHBOARD (Menu) -->
    <div id="dashboard" class="absolute inset-0 z-50 flex flex-col bg-[#111] overflow-hidden">
        
        <!-- Top Navigation -->
        <div class="h-16 bg-[#232527] border-b border-gray-700 flex items-center px-4 justify-between shadow-lg z-20">
            <div class="flex items-center gap-2">
                <div class="w-8 h-8 bg-gradient-to-tr from-gray-200 to-gray-400 border-2 border-white rounded-md transform rotate-12 shadow-md"></div>
                <span class="roblox-font text-2xl tracking-wide">ROBLOX<span class="text-red-500 text-sm align-top">WEB</span></span>
            </div>
            <div class="flex gap-6 text-sm font-bold text-gray-400">
                <button onclick="switchTab('games')" id="tab-games-btn" class="hover:text-white transition text-white border-b-2 border-white py-4">Games</button>
                <button onclick="switchTab('avatar')" id="tab-avatar-btn" class="hover:text-white transition py-4 border-b-2 border-transparent">Avatar</button>
                <button onclick="switchTab('settings')" id="tab-settings-btn" class="hover:text-white transition py-4 border-b-2 border-transparent">Settings</button>
            </div>
            <div class="flex items-center gap-2">
                <div class="text-right hidden sm:block">
                    <div class="text-xs text-gray-400">Welcome,</div>
                    <div class="text-sm font-bold" id="username-display">Guest 666</div>
                </div>
                <div class="w-8 h-8 rounded-full bg-yellow-400 border border-gray-500 overflow-hidden relative">
                    <!-- Simple Avatar Icon -->
                    <div class="absolute top-1 left-1 w-1 h-1 bg-black rounded-full"></div>
                    <div class="absolute top-1 right-1 w-1 h-1 bg-black rounded-full"></div>
                    <div class="absolute bottom-1 left-2 w-4 h-1 bg-black rounded-full"></div>
                </div>
            </div>
        </div>

        <!-- Content Area -->
        <div class="flex-1 overflow-y-auto relative bg-[#191b1d] p-4 md:p-8">
            
            <!-- GAMES TAB -->
            <div id="tab-games" class="max-w-6xl mx-auto">
                <h2 class="text-2xl font-bold mb-4 roblox-font">Recommended For You</h2>
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <!-- Place Card 1 -->
                    <div onclick="startGame('obby')" class="group cursor-pointer bg-[#2b2d31] rounded-xl overflow-hidden shadow-md hover:-translate-y-1 hover:shadow-xl transition duration-200">
                        <div class="h-40 bg-gradient-to-br from-purple-500 to-indigo-600 relative overflow-hidden">
                            <div class="absolute inset-0 bg-[url('https://images.unsplash.com/photo-1500964757637-c85e8a162699?q=80&w=1000&auto=format&fit=crop')] bg-cover opacity-50"></div>
                            <span class="absolute bottom-2 left-2 bg-black/60 px-2 py-0.5 rounded text-xs font-bold">4.8 â˜…</span>
                        </div>
                        <div class="p-3">
                            <h3 class="font-bold text-lg leading-tight group-hover:underline">Mega Obby Parkour</h3>
                            <p class="text-xs text-gray-400 mt-1">By RobloxWeb</p>
                            <div class="flex items-center gap-1 mt-2 text-xs text-gray-500">
                                <span class="w-2 h-2 rounded-full bg-green-500"></span> 1.2k Playing
                            </div>
                        </div>
                    </div>

                    <!-- Place Card 2 -->
                    <div onclick="startGame('baseplate')" class="group cursor-pointer bg-[#2b2d31] rounded-xl overflow-hidden shadow-md hover:-translate-y-1 hover:shadow-xl transition duration-200">
                        <div class="h-40 bg-gradient-to-br from-green-500 to-emerald-700 relative overflow-hidden">
                             <!-- Studs pattern css -->
                             <div class="absolute inset-0 opacity-30" style="background-image: radial-gradient(#000 15%, transparent 16%); background-size: 20px 20px;"></div>
                        </div>
                        <div class="p-3">
                            <h3 class="font-bold text-lg leading-tight group-hover:underline">Classic Baseplate</h3>
                            <p class="text-xs text-gray-400 mt-1">By RobloxWeb</p>
                            <div class="flex items-center gap-1 mt-2 text-xs text-gray-500">
                                <span class="w-2 h-2 rounded-full bg-green-500"></span> 500 Playing
                            </div>
                        </div>
                    </div>

                    <!-- Place Card 3 -->
                    <div onclick="startGame('city')" class="group cursor-pointer bg-[#2b2d31] rounded-xl overflow-hidden shadow-md hover:-translate-y-1 hover:shadow-xl transition duration-200">
                        <div class="h-40 bg-gradient-to-br from-orange-400 to-red-500 relative">
                             <div class="absolute bottom-0 w-full h-1/2 bg-black/20 skew-y-3"></div>
                        </div>
                        <div class="p-3">
                            <h3 class="font-bold text-lg leading-tight group-hover:underline">Red City Hangout</h3>
                            <p class="text-xs text-gray-400 mt-1">By BuilderMan</p>
                            <div class="flex items-center gap-1 mt-2 text-xs text-gray-500">
                                <span class="w-2 h-2 rounded-full bg-green-500"></span> 852 Playing
                            </div>
                        </div>
                    </div>

                    <!-- Place Card 4 -->
                    <div onclick="startGame('lava')" class="group cursor-pointer bg-[#2b2d31] rounded-xl overflow-hidden shadow-md hover:-translate-y-1 hover:shadow-xl transition duration-200">
                        <div class="h-40 bg-gradient-to-br from-red-600 to-yellow-500 relative overflow-hidden">
                             <div class="absolute inset-0 bg-[url('https://images.unsplash.com/photo-1619266465172-02a857c3556d?q=80&w=1000&auto=format&fit=crop')] bg-cover opacity-60"></div>
                        </div>
                        <div class="p-3">
                            <h3 class="font-bold text-lg leading-tight group-hover:underline">Floor is LAVA</h3>
                            <p class="text-xs text-gray-400 mt-1">By RobloxWeb</p>
                            <div class="flex items-center gap-1 mt-2 text-xs text-gray-500">
                                <span class="w-2 h-2 rounded-full bg-green-500"></span> 3.4k Playing
                            </div>
                        </div>
                    </div>

                    <!-- Place Card 5 (New) -->
                    <div onclick="startGame('rainbow')" class="group cursor-pointer bg-[#2b2d31] rounded-xl overflow-hidden shadow-md hover:-translate-y-1 hover:shadow-xl transition duration-200">
                        <div class="h-40 bg-gradient-to-br from-purple-500 to-pink-500 relative overflow-hidden">
                             <!-- Rainbow gradient overlay -->
                             <div class="absolute inset-0 opacity-60 bg-[linear-gradient(45deg,red,orange,yellow,green,blue,indigo,violet)]"></div>
                        </div>
                        <div class="p-3">
                            <h3 class="font-bold text-lg leading-tight group-hover:underline">Rainbow Parkour</h3>
                            <p class="text-xs text-gray-400 mt-1">By RobloxWeb</p>
                            <div class="flex items-center gap-1 mt-2 text-xs text-gray-500">
                                <span class="w-2 h-2 rounded-full bg-green-500"></span> 8.9k Playing
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AVATAR TAB -->
            <div id="tab-avatar" class="hidden max-w-4xl mx-auto h-full flex flex-col md:flex-row gap-8">
                <!-- Preview -->
                <div class="flex-1 bg-[#232527] rounded-2xl flex items-center justify-center relative border border-gray-700 min-h-[300px]">
                    <div class="absolute top-4 left-4 text-sm font-bold text-gray-400">PREVIEW</div>
                    <!-- CSS-only Avatar Preview -->
                    <div id="avatar-preview" class="relative w-32 h-64 transform transition-transform">
                        <!-- Head -->
                        <div id="prev-head" class="absolute top-0 left-1/2 -translate-x-1/2 w-16 h-16 bg-yellow-400 rounded-md border-2 border-black/10 shadow-lg z-10 overflow-hidden flex items-center justify-center">
                            <div id="prev-face-content" class="text-4xl select-none pt-2 opacity-80">ðŸ™‚</div>
                        </div>
                        <!-- Torso -->
                        <div id="prev-torso" class="absolute top-17 left-1/2 -translate-x-1/2 w-32 h-32 bg-blue-600 rounded-sm border-2 border-black/10 shadow-lg z-0">
                            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white/20 font-bold text-4xl">R</div>
                        </div>
                        <!-- Left Arm -->
                        <div id="prev-larm" class="absolute top-17 left-[-20px] w-12 h-32 bg-yellow-400 rounded-lg border-2 border-black/10 shadow-md -z-10 origin-top-right rotate-12"></div>
                        <!-- Right Arm -->
                        <div id="prev-rarm" class="absolute top-17 right-[-20px] w-12 h-32 bg-yellow-400 rounded-lg border-2 border-black/10 shadow-md -z-10 origin-top-left -rotate-12"></div>
                        <!-- Left Leg -->
                        <div id="prev-lleg" class="absolute top-[200px] left-[10px] w-14 h-32 bg-green-600 rounded-sm border-2 border-black/10 shadow-md"></div>
                        <!-- Right Leg -->
                        <div id="prev-rleg" class="absolute top-[200px] right-[10px] w-14 h-32 bg-green-600 rounded-sm border-2 border-black/10 shadow-md"></div>
                    </div>
                </div>

                <!-- Customization Panel -->
                <div class="w-full md:w-80 flex flex-col gap-6">
                    <h2 class="text-2xl font-bold roblox-font">Customize Avatar</h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-bold text-gray-400 mb-2">Skin Color (Head & Limbs)</label>
                            <div class="flex flex-wrap gap-2" id="skin-colors">
                                <!-- Colors injected by JS -->
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-400 mb-2">Torso Color</label>
                            <div class="flex flex-wrap gap-2" id="torso-colors"></div>
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-400 mb-2">Legs Color</label>
                            <div class="flex flex-wrap gap-2" id="leg-colors"></div>
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-400 mb-2">Face</label>
                            <div class="flex gap-3">
                                <button onclick="setFace('classic')" class="w-12 h-12 bg-[#333] rounded-lg border-2 border-gray-600 hover:border-white transition flex items-center justify-center text-2xl">ðŸ™‚</button>
                                <button onclick="setFace('chill')" class="w-12 h-12 bg-[#333] rounded-lg border-2 border-gray-600 hover:border-white transition flex items-center justify-center text-2xl">ðŸ˜Ž</button>
                                <button onclick="setFace('surprised')" class="w-12 h-12 bg-[#333] rounded-lg border-2 border-gray-600 hover:border-white transition flex items-center justify-center text-2xl">ðŸ˜®</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- SETTINGS TAB -->
            <div id="tab-settings" class="hidden max-w-xl mx-auto mt-8">
                <h2 class="text-2xl font-bold mb-6 roblox-font">Game Settings</h2>
                <div class="bg-[#2b2d31] p-6 rounded-xl space-y-6 shadow-md border border-gray-700">
                    
                    <!-- Nickname Input -->
                    <div>
                        <label class="font-bold text-gray-300 block mb-2">Nickname</label>
                        <input type="text" id="set-nickname" value="Guest 666" maxlength="15" class="w-full bg-black/40 border border-gray-600 rounded px-3 py-2 text-white focus:border-white outline-none placeholder-gray-500">
                    </div>

                    <!-- Speed Slider -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-gray-300">Walk Speed</label>
                            <span id="val-speed" class="font-mono text-yellow-400">18</span>
                        </div>
                        <input type="range" id="set-speed" min="10" max="100" value="18" class="w-full accent-blue-500">
                    </div>

                    <!-- Jump Slider -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-gray-300">Jump Power</label>
                            <span id="val-jump" class="font-mono text-yellow-400">22</span>
                        </div>
                        <input type="range" id="set-jump" min="10" max="100" value="22" class="w-full accent-green-500">
                    </div>

                    <!-- Gravity Slider -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="font-bold text-gray-300">Gravity</label>
                            <span id="val-gravity" class="font-mono text-yellow-400">40</span>
                        </div>
                        <input type="range" id="set-gravity" min="5" max="100" value="40" class="w-full accent-red-500">
                    </div>
                    
                    <div class="pt-4 border-t border-gray-600 text-xs text-gray-400 text-center">
                        Adjust these sliders to change how your character moves in the game!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- IN-GAME UI OVERLAY -->
    <div id="game-ui" class="hidden absolute inset-0 pointer-events-none z-10 flex flex-col justify-between">
        <!-- Top Bar (Reduced height for mobile) -->
        <div class="flex justify-between items-start p-4 bg-gradient-to-b from-black/50 to-transparent h-16 relative z-30">
            <button onclick="exitGame()" class="pointer-events-auto bg-gray-900/80 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-bold border border-gray-600 transition flex items-center gap-2">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M18 6L6 18M6 6l12 12"></path></svg>
                LEAVE
            </button>
            <div class="bg-gray-900/60 px-4 py-2 rounded-full border border-gray-600 backdrop-blur-md">
                <span id="place-name" class="font-bold text-white tracking-wide">Place Name</span>
            </div>
        </div>

        <!-- CHAT UI (Moved Higher: top-16) -->
        <div id="chat-ui" class="absolute top-16 left-4 w-64 md:w-80 flex flex-col gap-2 pointer-events-auto z-30 transition-all duration-300">
            <div class="flex justify-between items-center mb-1">
                <button onclick="toggleChat()" class="bg-black/60 text-white px-2 py-1 rounded text-xs font-bold border border-gray-600 hover:bg-black/80">
                    <span id="chat-toggle-icon">â–¼</span> CHAT
                </button>
            </div>
            <div id="chat-container" class="flex flex-col gap-2 transition-all duration-300 origin-top">
                <div id="chat-messages" class="h-40 md:h-56 bg-black/40 backdrop-blur-sm rounded-xl p-2 overflow-y-auto flex flex-col gap-1 shadow-lg scrollbar-hide text-sm font-semibold text-shadow-sm">
                    <div class="text-yellow-400">[System]: Welcome to RobloxWeb!</div>
                    <div class="text-yellow-400">[System]: Chat is now live.</div>
                </div>
                <input type="text" id="chat-input" maxlength="60" placeholder="Click here to chat..." class="bg-black/60 text-white px-3 py-2 rounded-lg border border-gray-600 focus:border-white focus:bg-black/80 outline-none transition placeholder-gray-400">
            </div>
        </div>

        <!-- Mobile/Desktop Zoom Slider (Right Side) -->
        <div class="absolute right-6 top-1/2 -translate-y-1/2 pointer-events-auto flex flex-col items-center gap-2 bg-black/40 p-3 rounded-full backdrop-blur-sm">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            <input type="range" id="zoom-slider" min="5" max="30" value="10" step="0.5" class="h-32 w-2 appearance-none -rotate-180" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
        </div>

        <!-- Mobile Controls (lg:hidden ensures visibility on landscape phones) -->
        <div id="mobile-controls" class="absolute inset-0 pointer-events-none z-20 lg:hidden flex flex-col justify-end pb-12 px-6">
             <div class="flex justify-between items-end w-full">
                 <!-- Joystick Zone -->
                 <div id="joystick-zone" class="w-36 h-36 bg-white/10 rounded-full border border-white/20 backdrop-blur-sm pointer-events-auto relative touch-none">
                     <div id="joystick-knob" class="w-14 h-14 bg-white/90 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-lg"></div>
                 </div>

                 <!-- Jump Button -->
                 <button id="jump-btn" class="pointer-events-auto w-24 h-24 bg-white/20 rounded-full border border-white/30 backdrop-blur-md flex items-center justify-center active:bg-white/40 transition">
                     <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
                 </button>
             </div>
        </div>
        
        <!-- PC Controls Hint (lg:block ensures hidden on landscape phones) -->
        <div id="pc-controls-hint" class="hidden lg:block absolute bottom-6 left-1/2 -translate-x-1/2 text-center pointer-events-none opacity-60">
            <div class="bg-black/50 px-4 py-2 rounded text-sm font-semibold">WASD to Move â€¢ SPACE to Jump â€¢ Right Click Drag to Look</div>
        </div>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container" class="absolute inset-0 z-0 bg-sky-400 hidden"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL CONFIG & STATE ---
        const CONFIG = {
            gravity: 40,
            jumpForce: 15,
            speed: 18,
            rotSpeed: 5
        };
        
        const AVATAR = {
            head: '#facc15', // yellow-400
            torso: '#2563eb', // blue-600
            legs: '#16a34a',  // green-600
            face: 'classic'
        };

        let currentPlace = 'baseplate';
        let isGameRunning = false;
        
        // --- THREE.JS GLOBALS ---
        let camera, scene, renderer;
        let playerGroup, playerMeshParts = {};
        
        // Physics
        let velocity = new THREE.Vector3();
        let onGround = false;
        let inputVector = { x: 0, y: 0 }; // Joystick/WASD input
        let jumpPressed = false;
        let colliders = []; // Array to store objects for collision
        let playerBox = new THREE.Box3(); // Reusable box
        let spawnPoint = new THREE.Vector3(0, 5, 0);

        // Camera State
        let cameraDist = 10;
        let cameraAngleX = 0; // Vertical
        let cameraAngleY = Math.PI; // Horizontal
        
        // --- UI LOGIC ---
        
        window.switchTab = (tab) => {
            const tabs = ['games', 'avatar', 'settings'];
            tabs.forEach(t => {
                document.getElementById(`tab-${t}`).classList.add('hidden');
                const btn = document.getElementById(`tab-${t}-btn`);
                btn.classList.replace('border-white', 'border-transparent');
                btn.classList.remove('text-white');
            });
            
            document.getElementById(`tab-${tab}`).classList.remove('hidden');
            const activeBtn = document.getElementById(`tab-${tab}-btn`);
            activeBtn.classList.replace('border-transparent', 'border-white');
            activeBtn.classList.add('text-white');
        };

        // Settings Logic
        const nameInput = document.getElementById('set-nickname');
        if(nameInput) {
            nameInput.addEventListener('input', (e) => {
                const val = e.target.value || 'Guest';
                document.getElementById('username-display').innerText = val;
            });
        }

        document.getElementById('set-speed').addEventListener('input', (e) => {
            CONFIG.speed = parseFloat(e.target.value);
            document.getElementById('val-speed').innerText = CONFIG.speed;
        });
        document.getElementById('set-jump').addEventListener('input', (e) => {
            CONFIG.jumpForce = parseFloat(e.target.value);
            document.getElementById('val-jump').innerText = CONFIG.jumpForce;
        });
        document.getElementById('set-gravity').addEventListener('input', (e) => {
            CONFIG.gravity = parseFloat(e.target.value);
            document.getElementById('val-gravity').innerText = CONFIG.gravity;
        });

        window.toggleChat = () => {
            const container = document.getElementById('chat-container');
            const icon = document.getElementById('chat-toggle-icon');
            if (container.classList.contains('scale-y-0')) {
                container.classList.remove('scale-y-0', 'h-0', 'opacity-0');
                icon.innerText = 'â–¼';
            } else {
                container.classList.add('scale-y-0', 'h-0', 'opacity-0');
                icon.innerText = 'â–¶';
            }
        };

        window.startGame = (placeId) => {
            currentPlace = placeId;
            document.getElementById('dashboard').style.display = 'none';
            document.getElementById('game-ui').classList.remove('hidden');
            document.getElementById('canvas-container').classList.remove('hidden');
            
            let name = 'Baseplate';
            if(placeId === 'obby') name = 'Mega Obby';
            if(placeId === 'city') name = 'Red City';
            if(placeId === 'lava') name = 'Lava Survival';
            if(placeId === 'rainbow') name = 'Rainbow Parkour';
            document.getElementById('place-name').innerText = name;
            
            // Fullscreen check for mobile
            if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                 try {
                     document.documentElement.requestFullscreen().catch(e => {});
                 } catch(e) {}
            }

            // Force mobile controls check
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.getElementById('mobile-controls').classList.remove('lg:hidden');
                document.getElementById('mobile-controls').classList.remove('hidden');
                document.getElementById('pc-controls-hint').classList.add('hidden');
            }

            isGameRunning = true;
            initGame();
        };

        window.exitGame = () => {
            isGameRunning = false;
            document.getElementById('dashboard').style.display = 'flex';
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('canvas-container').classList.add('hidden');
            
            // Clean up Three.js
            if(renderer) {
                renderer.domElement.remove();
                renderer.dispose();
            }
            colliders = []; // Clear collisions
            spawnPoint.set(0, 5, 0); // Reset spawn
            
            if(document.fullscreenElement) {
                try { document.exitFullscreen(); } catch(e){}
            }
        };

        // Initialize Avatar Color Pickers
        const colors = ['#ef4444', '#f97316', '#facc15', '#22c55e', '#3b82f6', '#a855f7', '#ec4899', '#ffffff', '#1f2937'];
        
        function createColorPicker(containerId, part) {
            const container = document.getElementById(containerId);
            colors.forEach(c => {
                const btn = document.createElement('div');
                btn.className = 'w-8 h-8 rounded-full cursor-pointer border-2 border-transparent hover:scale-110 transition shadow-sm';
                btn.style.backgroundColor = c;
                btn.onclick = () => {
                    AVATAR[part] = c;
                    updateAvatarPreview();
                };
                container.appendChild(btn);
            });
        }
        
        createColorPicker('skin-colors', 'head');
        createColorPicker('torso-colors', 'torso');
        createColorPicker('leg-colors', 'legs');

        window.setFace = (type) => {
            AVATAR.face = type;
            updateAvatarPreview();
        }

        function updateAvatarPreview() {
            // Update CSS Preview
            document.getElementById('prev-head').style.backgroundColor = AVATAR.head;
            document.getElementById('prev-larm').style.backgroundColor = AVATAR.head;
            document.getElementById('prev-rarm').style.backgroundColor = AVATAR.head;
            document.getElementById('prev-torso').style.backgroundColor = AVATAR.torso;
            document.getElementById('prev-lleg').style.backgroundColor = AVATAR.legs;
            document.getElementById('prev-rleg').style.backgroundColor = AVATAR.legs;
            
            const faceEl = document.getElementById('prev-face-content');
            if(AVATAR.face === 'classic') faceEl.innerText = 'ðŸ™‚';
            if(AVATAR.face === 'chill') faceEl.innerText = 'ðŸ˜Ž';
            if(AVATAR.face === 'surprised') faceEl.innerText = 'ðŸ˜®';
        }
        updateAvatarPreview();

        // Zoom Slider
        const zoomSlider = document.getElementById('zoom-slider');
        zoomSlider.addEventListener('input', (e) => {
            cameraDist = parseFloat(e.target.value);
        });

        // Chat Logic
        const chatInput = document.getElementById('chat-input');
        const chatMsgs = document.getElementById('chat-messages');

        chatInput.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' && chatInput.value.trim() !== '') {
                addMessage('Guest 666', chatInput.value);
                chatInput.value = '';
                chatInput.blur(); // Unfocus to return controls to game
            }
            e.stopPropagation(); // Prevent WASD while typing
        });

        // Prevent movement keys while typing (backup)
        chatInput.addEventListener('focus', () => { inputVector.x = 0; inputVector.y = 0; });

        function addMessage(user, msg) {
            const div = document.createElement('div');
            div.innerHTML = `<span class="font-bold text-white shadow-black drop-shadow-md">[${user}]:</span> <span class="text-white drop-shadow-md">${msg}</span>`;
            chatMsgs.appendChild(div);
            chatMsgs.scrollTop = chatMsgs.scrollHeight;
        }

        // --- GAME ENGINE ---

        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            colliders = []; // Reset colliders
            spawnPoint.set(0, 5, 0);

            generateMap(currentPlace);
            createPlayer();
            setupInputs();
            animate();
        }

        function createFaceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = AVATAR.head; 
            ctx.fillRect(0,0,128,128);
            
            ctx.fillStyle = 'black';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';

            if (AVATAR.face === 'classic') {
                // Eyes
                ctx.beginPath(); ctx.arc(40, 50, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(88, 50, 8, 0, Math.PI*2); ctx.fill();
                // Smile
                ctx.beginPath(); ctx.arc(64, 65, 24, 0.2 * Math.PI, 0.8 * Math.PI); ctx.stroke();
            } else if (AVATAR.face === 'chill') {
                // Sunglasses
                ctx.fillRect(20, 45, 40, 20);
                ctx.fillRect(68, 45, 40, 20);
                ctx.moveTo(60, 55); ctx.lineTo(68, 55); ctx.stroke();
                // Cool Smile
                ctx.beginPath(); ctx.arc(64, 80, 15, 0, Math.PI); ctx.stroke();
            } else if (AVATAR.face === 'surprised') {
                // Eyes
                ctx.beginPath(); ctx.arc(40, 45, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(88, 45, 8, 0, Math.PI*2); ctx.fill();
                // Mouth
                ctx.beginPath(); ctx.ellipse(64, 80, 10, 15, 0, 0, Math.PI*2); ctx.fill();
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        function createPlayer() {
            playerGroup = new THREE.Group();
            playerGroup.position.copy(spawnPoint);
            playerGroup.scale.set(0.65, 0.65, 0.65); // Smaller scale as requested

            // Materials
            const faceTex = createFaceTexture();
            const headColorMat = new THREE.MeshStandardMaterial({ color: AVATAR.head });
            const faceMat = new THREE.MeshStandardMaterial({ map: faceTex });
            // Face only on front (index 4 in BoxGeometry usually, but let's just use array)
            // Order: right, left, top, bottom, front, back
            const headMaterials = [headColorMat, headColorMat, headColorMat, headColorMat, faceMat, headColorMat];

            const torsoMat = new THREE.MeshStandardMaterial({ color: AVATAR.torso });
            const limbMat = new THREE.MeshStandardMaterial({ color: AVATAR.head }); // Arms match head
            const legMat = new THREE.MeshStandardMaterial({ color: AVATAR.legs });

            // 1. Head (Size 1.2x1.2x1.2 for classic look)
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), headMaterials);
            head.position.y = 4.6; 
            head.castShadow = true;
            playerGroup.add(head);

            // 2. Torso (Size 2x2x1)
            const torso = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), torsoMat);
            torso.position.y = 3; 
            torso.castShadow = true;
            playerGroup.add(torso);

            // 3. Arms (Size 1x2x1)
            const armGeo = new THREE.BoxGeometry(1, 2, 1);
            armGeo.translate(0, -1, 0); // Pivot at shoulder
            
            const leftArm = new THREE.Mesh(armGeo, limbMat);
            leftArm.position.set(-1.55, 4, 0); 
            leftArm.castShadow = true;
            playerGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, limbMat);
            rightArm.position.set(1.55, 4, 0); 
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // 4. Legs (Size 1x2x1)
            const legGeo = new THREE.BoxGeometry(1, 2, 1);
            legGeo.translate(0, -1, 0); // Pivot at hip
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.5, 2, 0); 
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.5, 2, 0); 
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            scene.add(playerGroup);
            playerMeshParts = { leftArm, rightArm, leftLeg, rightLeg, head };
        }

        function generateMap(type) {
            // Default Floor (for city/baseplate)
            if (type !== 'lava') {
                const planeGeo = new THREE.PlaneGeometry(300, 300);
                planeGeo.rotateX(-Math.PI / 2);
                
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#444'; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(32, 32, 14, 0, Math.PI * 2); ctx.fill();
                const tex = new THREE.CanvasTexture(canvas);
                tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(150, 150);
                tex.magFilter = THREE.NearestFilter;

                const floorMat = new THREE.MeshStandardMaterial({ map: tex });
                const floor = new THREE.Mesh(planeGeo, floorMat);
                floor.receiveShadow = true;
                scene.add(floor);
            }

            if (type === 'lava') {
                // Deadly Lava Floor
                const planeGeo = new THREE.PlaneGeometry(300, 300);
                planeGeo.rotateX(-Math.PI / 2);
                const lavaMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000 });
                const lava = new THREE.Mesh(planeGeo, lavaMat);
                lava.position.y = -2;
                scene.add(lava);
                
                // Safe Start Platform
                const start = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 10), new THREE.MeshStandardMaterial({color: 0x888888}));
                start.position.set(0, -0.5, 0);
                start.receiveShadow = true;
                scene.add(start);
                colliders.push(start);
                
                // Random Floating Platforms
                for(let i=0; i<50; i++) {
                    const w = 3 + Math.random()*5;
                    const d = 3 + Math.random()*5;
                    const x = (Math.random()-0.5)*100;
                    const z = (Math.random()-0.5)*100;
                    if(Math.abs(x) < 5 && Math.abs(z) < 5) continue; // Skip start area
                    
                    const p = new THREE.Mesh(new THREE.BoxGeometry(w, 1, d), new THREE.MeshStandardMaterial({color: 0x444444}));
                    p.position.set(x, Math.random()*5, z);
                    p.castShadow = true;
                    p.receiveShadow = true;
                    scene.add(p);
                    colliders.push(p);
                }
            }
            else if (type === 'obby') {
                const matNormal = new THREE.MeshStandardMaterial({ color: 0xff0055 });
                const matCheck = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green Checkpoint
                
                let cx = 0, cy = 0, cz = 0;
                
                for(let i=0; i<100; i++) {
                    const isCheckpoint = (i > 0 && i % 10 === 0);
                    const size = isCheckpoint ? 6 : 4;
                    const geo = new THREE.BoxGeometry(size, 1, size);
                    const mesh = new THREE.Mesh(geo, isCheckpoint ? matCheck : matNormal);
                    
                    // Logic for generating path
                    if(i === 0) {
                        cx = 0; cy = 1.5; cz = 0;
                    } else {
                        const dir = Math.floor(Math.random() * 3); // 0: straight, 1: left, 2: right
                        const dist = 5 + Math.random()*3;
                        const jumpH = 1 + Math.random()*1.5;
                        
                        if(i % 10 === 0) { // Checkpoint always flat
                             cy += 0;
                        } else {
                             cy += jumpH;
                        }

                        if(Math.random() > 0.6) cx += (Math.random()-0.5)*10;
                        cz += dist;
                    }
                    
                    mesh.position.set(cx, cy, cz);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    if (isCheckpoint) {
                         mesh.userData.isCheckpoint = true;
                    }
                    
                    scene.add(mesh);
                    mesh.geometry.computeBoundingBox();
                    colliders.push(mesh);
                }
            } else if (type === 'city') {
                for(let i=0; i<30; i++) {
                    const h = 10 + Math.random() * 40;
                    const w = 10 + Math.random()*15;
                    const d = 10 + Math.random()*15;
                    const b = new THREE.Mesh(
                        new THREE.BoxGeometry(w, h, d),
                        new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
                    );
                    b.position.set((Math.random()-0.5)*200, h/2, (Math.random()-0.5)*200);
                    b.castShadow = true;
                    b.receiveShadow = true;
                    scene.add(b);
                    
                    b.geometry.computeBoundingBox();
                    colliders.push(b);
                }
            } else if (type === 'rainbow') {
                const colors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3];
                let cx = 0, cy = 0, cz = 0;
                
                // Start Platform
                const start = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 10), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
                start.position.set(0, -0.5, 0);
                start.receiveShadow = true;
                scene.add(start);
                colliders.push(start);
                
                // 100 Stages
                for(let i=0; i<100; i++) {
                    const isCheckpoint = (i > 0 && i % 10 === 0);
                    const stageColor = colors[Math.floor(i/10) % colors.length];
                    
                    const mat = new THREE.MeshStandardMaterial({ color: isCheckpoint ? 0xffffff : stageColor });
                    
                    let geo;
                    if(isCheckpoint) {
                        geo = new THREE.BoxGeometry(8, 1, 8);
                        cy += 1; // Small step up to checkpoint
                    } else {
                        // Varying Geometry
                        const r = Math.random();
                        if(r > 0.6) geo = new THREE.CylinderGeometry(2, 2, 1, 16);
                        else if (r > 0.3) geo = new THREE.BoxGeometry(4, 1, 4);
                        else geo = new THREE.BoxGeometry(2, 1, 6); // Narrow beam
                        
                        cy += 2 + Math.random(); // Climbing up
                    }

                    // Winding path generation
                    const angle = i * 0.5;
                    const spread = 8 + (i * 0.1); 
                    
                    // Add some noise to position
                    if (i > 0) {
                        cx += Math.cos(angle) * (5 + Math.random() * 2);
                        cz += Math.sin(angle) * (5 + Math.random() * 2);
                    } else {
                        cx = 0; cz = 10; cy = 2;
                    }

                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(cx, cy, cz);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    if (isCheckpoint) {
                        mesh.userData.isCheckpoint = true;
                        // Add Checkpoint Flag
                        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 6), new THREE.MeshStandardMaterial({color: 0x888888}));
                        pole.position.y = 3;
                        mesh.add(pole);
                        const flag = new THREE.Mesh(new THREE.PlaneGeometry(3, 2), new THREE.MeshStandardMaterial({color: 0x00ff00, side: THREE.DoubleSide}));
                        flag.position.set(1.5, 5, 0);
                        mesh.add(flag);
                    }

                    scene.add(mesh);
                    mesh.geometry.computeBoundingBox();
                    colliders.push(mesh);
                }
            }
        }

        function setupInputs() {
            const keys = {};
            document.addEventListener('keydown', (e) => { 
                if(document.activeElement === chatInput) return; // Ignore if typing
                keys[e.code] = true; updateInputVector(); 
            });
            document.addEventListener('keyup', (e) => { 
                keys[e.code] = false; updateInputVector(); 
            });

            function updateInputVector() {
                inputVector.x = (keys['KeyD'] || keys['ArrowRight'] ? 1 : 0) - (keys['KeyA'] || keys['ArrowLeft'] ? 1 : 0);
                inputVector.y = (keys['KeyW'] || keys['ArrowUp'] ? 1 : 0) - (keys['KeyS'] || keys['ArrowDown'] ? 1 : 0);
                if (keys['Space']) jumpPressed = true;
            }

            // Touch Joystick & Camera
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            let zoneRect;
            let joystickTouchId = null;
            let cameraTouchId = null;
            let prevX = 0, prevY = 0;
            
            // Joystick Events
            zone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                joystickTouchId = touch.identifier;
                zoneRect = zone.getBoundingClientRect();
                updateJoystick(touch);
            }, {passive: false});

            zone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === joystickTouchId) {
                        updateJoystick(e.changedTouches[i]);
                    }
                }
            }, {passive: false});

            zone.addEventListener('touchend', (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === joystickTouchId) {
                        joystickTouchId = null;
                        knob.style.transform = `translate(-50%, -50%)`;
                        inputVector.x = 0; inputVector.y = 0;
                    }
                }
            });

            function updateJoystick(touch) {
                const center = { x: zoneRect.left + zoneRect.width/2, y: zoneRect.top + zoneRect.height/2 };
                let dx = touch.clientX - center.x;
                let dy = touch.clientY - center.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const max = 35;
                if(dist > max) { dx = (dx/dist)*max; dy = (dy/dist)*max; }
                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                inputVector.x = dx / max;
                inputVector.y = -dy / max;
            }

            // Jump Button
            const jumpBtn = document.getElementById('jump-btn');
            jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); jumpPressed = true; });

            // Camera Touch (Anywhere else)
            document.addEventListener('touchstart', e => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.target.closest('#mobile-controls') || t.target.closest('#zoom-slider') || t.target.closest('#chat-ui')) continue;
                    
                    if (cameraTouchId === null) {
                        cameraTouchId = t.identifier;
                        prevX = t.clientX;
                        prevY = t.clientY;
                    }
                }
            }, {passive: false});

            document.addEventListener('touchmove', e => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === cameraTouchId) {
                        const deltaX = t.clientX - prevX;
                        const deltaY = t.clientY - prevY;
                        prevX = t.clientX;
                        prevY = t.clientY;
                        rotateCamera(deltaX, deltaY);
                    }
                }
            }, {passive: false});

            document.addEventListener('touchend', e => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === cameraTouchId) {
                        cameraTouchId = null;
                    }
                }
            });

            // Mouse Look (PC)
            let isDragging = false;
            document.addEventListener('mousedown', (e) => {
                if(e.button === 2) { isDragging = true; prevX = e.clientX; prevY = e.clientY; }
            });
            document.addEventListener('mouseup', () => isDragging = false);
            document.addEventListener('mousemove', (e) => {
                if(isDragging) {
                    const deltaX = e.clientX - prevX;
                    const deltaY = e.clientY - prevY;
                    prevX = e.clientX;
                    prevY = e.clientY;
                    rotateCamera(deltaX, deltaY);
                }
            });
            document.addEventListener('contextmenu', e => e.preventDefault());
        }

        function rotateCamera(dx, dy) {
            const sensitivity = 0.005;
            // FIXED: Drag Right (dx > 0) -> Camera rotates Left (angle decreases)
            // This makes the world appear to rotate Right.
            cameraAngleY -= dx * sensitivity; 
            
            // Vertical: Drag Up (dy < 0) -> Camera moves Down (Look Up)
            cameraAngleX += dy * sensitivity;
            cameraAngleX = Math.max(-0.5, Math.min(1.2, cameraAngleX));
        }

        function checkCollisions() {
            const center = playerGroup.position.clone().add(new THREE.Vector3(0, 2.25, 0));
            playerBox.setFromCenterAndSize(center, new THREE.Vector3(1.5, 4.5, 1.5));

            for (let obj of colliders) {
                const objBox = new THREE.Box3().setFromObject(obj);
                if (playerBox.intersectsBox(objBox)) {
                    // Checkpoint Logic
                    if (obj.userData.isCheckpoint) {
                        spawnPoint.copy(obj.position).add(new THREE.Vector3(0, 3, 0));
                        // Flash effect could go here
                    }
                    return true;
                }
            }
            return false;
        }

        function animate() {
            if(!isGameRunning) return;
            requestAnimationFrame(animate);

            const dt = 0.016; 

            // Respawn Logic
            if(playerGroup.position.y < -20) {
                playerGroup.position.copy(spawnPoint);
                velocity.set(0,0,0);
                // Reset camera angle slightly
                cameraAngleX = 0;
            }

            // Camera Basis
            const camDir = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), cameraAngleY).normalize();
            const camRight = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), cameraAngleY);
            
            const moveDir = new THREE.Vector3().addScaledVector(camDir, inputVector.y).addScaledVector(camRight, inputVector.x);
            moveDir.y = 0;
            
            if (moveDir.length() > 0.1) {
                moveDir.normalize();
                
                // Character Rotation
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                let diff = targetRot - playerGroup.rotation.y;
                while(diff > Math.PI) diff -= Math.PI*2;
                while(diff < -Math.PI) diff += Math.PI*2;
                playerGroup.rotation.y += diff * 0.2;

                // X Movement & Collision
                playerGroup.position.x += moveDir.x * CONFIG.speed * dt;
                playerGroup.updateMatrixWorld();
                if(checkCollisions()) playerGroup.position.x -= moveDir.x * CONFIG.speed * dt; 

                // Z Movement & Collision
                playerGroup.position.z += moveDir.z * CONFIG.speed * dt;
                playerGroup.updateMatrixWorld();
                if(checkCollisions()) playerGroup.position.z -= moveDir.z * CONFIG.speed * dt; 

                velocity.x = moveDir.x * CONFIG.speed;
                velocity.z = moveDir.z * CONFIG.speed;
                
                // Animation
                const time = Date.now() * 0.01;
                playerMeshParts.leftArm.rotation.x = Math.sin(time) * 0.5;
                playerMeshParts.rightArm.rotation.x = -Math.sin(time) * 0.5;
                playerMeshParts.leftLeg.rotation.x = -Math.sin(time) * 0.5;
                playerMeshParts.rightLeg.rotation.x = Math.sin(time) * 0.5;
            } else {
                velocity.x = 0; velocity.z = 0;
                playerMeshParts.leftArm.rotation.x = 0;
                playerMeshParts.rightArm.rotation.x = 0;
                playerMeshParts.leftLeg.rotation.x = 0;
                playerMeshParts.rightLeg.rotation.x = 0;
            }

            // Y Gravity & Collision
            velocity.y -= CONFIG.gravity * dt;
            playerGroup.position.y += velocity.y * dt;
            playerGroup.updateMatrixWorld();

            if (checkCollisions()) {
                if(velocity.y < 0) { // Falling down onto something
                    playerGroup.position.y -= velocity.y * dt; // Revert
                    velocity.y = 0;
                    onGround = true;
                } else if (velocity.y > 0) { // Hitting head
                    playerGroup.position.y -= velocity.y * dt;
                    velocity.y = 0;
                }
            }

            // Floor Collision (Only for non-lava, non-obby maps)
            if (currentPlace !== 'obby' && currentPlace !== 'lava') {
                if (playerGroup.position.y < 0) {
                    playerGroup.position.y = 0;
                    velocity.y = 0;
                    onGround = true;
                }
            }
            
            if (onGround && jumpPressed) {
                velocity.y = CONFIG.jumpForce;
                onGround = false;
                jumpPressed = false;
            }

            // Camera target: Head/Torso area (y+3)
            const camX = playerGroup.position.x + Math.sin(cameraAngleY) * cameraDist * Math.cos(cameraAngleX);
            const camY = playerGroup.position.y + 3 + Math.sin(cameraAngleX) * cameraDist;
            const camZ = playerGroup.position.z + Math.cos(cameraAngleY) * cameraDist * Math.cos(cameraAngleX);
            
            camera.position.set(camX, camY, camZ);
            camera.lookAt(playerGroup.position.x, playerGroup.position.y + 3, playerGroup.position.z);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            if(camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
